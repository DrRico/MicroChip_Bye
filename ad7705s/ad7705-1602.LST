C51 COMPILER V9.57.0.0   AD7705_1602                                                       06/04/2020 17:55:56 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE AD7705_1602
OBJECT MODULE PLACED IN ad7705-1602.OBJ
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ad7705-1602.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1           //--------------------------AD7705------------------------
   2          //功能：ADC，可编程控制增益和截止频率
   3          //-------------------------------------------------------
   4          /***************************************************************
   5          *程序功能描述：
   6          *本程序可作为AD7705的调试程序，能够使AD7705工作在16倍增益
   7          *双极性缓冲模式下工作，更新频率为200HZ，数字滤波器的截止频率为52.4HZ
   8          *如果用在F020中只要改变如下端口即可：
   9          *sbit AD7705_DATA=P3^0;       // AD7705 input & output data
  10          *sbit AD7705_CLK=P3^1;        // AD7705 数据传输时钟
  11          *sbit AD7705_DRDY=P1^2;       // AD7705 数据输入输出检测位
  12          *sbit AD7705_CS  =P1^3;       // AD7705 片选
  13          *数据输出储存在全局变量：unsigned char MSB_Data,LSB_Data中
  14          *其中前者储存高八位，后者储存第八位
  15          *******************************************************************/
  16          
  17          #include<reg52.h>
  18          #include<absacc.h>
  19          #include<intrins.h>
  20          #include<math.h>
  21          
  22          sbit RS = P2^7;   //定义端口 
  23          sbit RW = P2^6;
  24          sbit EN = P2^5;
  25          
  26          
  27          sbit R_S = P1^1; 
  28          
  29          #define RS_CLR RS=0 
  30          #define RS_SET RS=1
  31          #define RW_CLR RW=0 
  32          #define RW_SET RW=1 
  33          #define EN_CLR EN=0
  34          #define EN_SET EN=1       //液晶显示代码
  35          #define AD_CLK_WIDTH 1 /*AD7705串口时钟脉冲宽度*/
  36          //-------------------------串口通讯----------------------
  37          sbit AD7705_DATA=P1^2;       // AD7705 数据输入输出
  38          sbit AD7705_CLK=P1^3;        // AD7705 数据传输时钟
  39          sbit AD7705_DRDY=P1^5;       // AD7705 数据输入输出检测位
  40          sbit AD7705_CS=P1^0;       // AD7705 片选
  41          unsigned char MSB_Data,LSB_Data;
  42          
  43          unsigned char Timerint1,Timerint2,Sec,Min,H,Alm,AT,AlmTime;
  44          unsigned int ndata;
  45                
  46          
  47          unsigned char no[6];
  48          
  49          /******************************************************************/
  50          /*                    微秒延时函数                                */
  51          /******************************************************************/
  52          void delay_us(unsigned int n) //延时 如果需要高精度延时 请嵌入汇编
  53          { 
  54   1       for( ;n>0 ;n-- );
  55   1       }
C51 COMPILER V9.57.0.0   AD7705_1602                                                       06/04/2020 17:55:56 PAGE 2   

  56          /******************************************************************/
  57          /*                    毫秒函数声明                                */
  58          /******************************************************************/
  59           void delay_ms(unsigned char i) 
  60           { 
  61   1       unsigned char a, b; 
  62   1       for (a = 1; a < i; a++) 
  63   1       {
  64   2         for (b = 1; b; b++) 
  65   2         {   ;   } 
  66   2          }
  67   1       }
  68          /******************************************************************/
  69          /*                   写入命令函数                                 */
  70          /******************************************************************/
  71           void LCD_write_com(unsigned char com) 
  72           {  
  73   1       RS_CLR; 
  74   1       RW_CLR; 
  75   1       EN_SET; 
  76   1       P0 = com; 
  77   1       delay_us(5); 
  78   1       EN_CLR;
  79   1       }
  80          /******************************************************************/
  81          /*                   写入数据函数                                 */
  82          /******************************************************************/
  83           void LCD_write_Data(unsigned char Data) 
  84           { 
  85   1       RS_SET; 
  86   1       RW_CLR; 
  87   1       EN_SET; 
  88   1       P0 = Data; 
  89   1       delay_us(5); 
  90   1       EN_CLR;
  91   1       }
  92          /******************************************************************/
  93          /*                   清屏函数                                     */
  94          /******************************************************************/
  95           void LCD_clear(void) 
  96           { 
  97   1       LCD_write_com(0x01); 
  98   1       delay_ms(5);}
  99          /******************************************************************/
 100          /*                   写入字符串函数                               */
 101          /******************************************************************/
 102           void LCD_write_str(unsigned char x,unsigned char y,unsigned char *s) 
 103           {     
 104   1       if (y == 0) 
 105   1       {     
 106   2       LCD_write_com(0x80 + x);     
 107   2       }
 108   1       else 
 109   1       {     
 110   2       LCD_write_com(0xC0 + x);     
 111   2       }        
 112   1       while (*s) 
 113   1       {     
 114   2       LCD_write_Data( *s);     
 115   2       s ++;     
 116   2       }
 117   1       }
C51 COMPILER V9.57.0.0   AD7705_1602                                                       06/04/2020 17:55:56 PAGE 3   

 118          
 119          /******************************************************************/
 120          /*                   初始化函数                                   */
 121          /******************************************************************/
 122           void LCD_init(void) 
 123           {
 124   1         LCD_write_com(0x38);    /*显示模式设置*/ 
 125   1         delay_ms(5); 
 126   1         LCD_write_com(0x38); 
 127   1         delay_ms(5); 
 128   1         LCD_write_com(0x38); 
 129   1         delay_ms(5); 
 130   1         LCD_write_com(0x38);  
 131   1         LCD_write_com(0x08);    /*显示关闭*/ 
 132   1         LCD_write_com(0x01);    /*显示清屏*/ 
 133   1         LCD_write_com(0x06);    /*显示光标移动设置*/ 
 134   1         delay_ms(5); 
 135   1         LCD_write_com(0x0C);    /*显示开及光标设置*/
 136   1         }
 137             
 138          /******************************************************************/
 139          /*                   消磁                                   */
 140          /******************************************************************/
 141          
 142          //--------------------------------------------------------------------
 143          //函数名：AD7705_Write_Reg()
 144          //功能：对AD7705中的各寄存器进行写操作
 145          //参数：要对AD7705各寄存器写入得控制字
 146          //返回值：无
 147          //变量：无
 148          //备注：无
 149          //--------------------------------------------------------------------
 150          void AD7705_Write_Reg(unsigned char Data_byte)
 151          { 
 152   1       unsigned char i;
 153   1       AD7705_CS = 0;            //选通片选
 154   1       AD7705_CLK = 1;           
 155   1              _nop_();           //延时可不要
 156   1            _nop_();
 157   1       for(i = 0; i < 8; i++) 
 158   1       {
 159   2           AD7705_DATA = (bit)(Data_byte & 0x80);     //取位值
 160   2         AD7705_CLK = 0;
 161   2           _nop_();
 162   2         _nop_();
 163   2           _nop_();
 164   2           AD7705_CLK = 1;
 165   2           Data_byte <<= 1;                //向左移位
 166   2       }
 167   1        _nop_();
 168   1      AD7705_CS = 1;                   //禁止片选
 169   1      }
 170          
 171          //-------------------------------------------------------------------
 172          //函数名：AD7705_Read_Reg
 173          //功能：读AD7705中各寄存器
 174          //参数：无
 175          //返回值：从AD7705寄存器中读出的数据
 176          //变量：无
 177          //备注：无
 178          //-------------------------------------------------------------------
 179          unsigned char AD7705_Read_Reg()
C51 COMPILER V9.57.0.0   AD7705_1602                                                       06/04/2020 17:55:56 PAGE 4   

 180          { 
 181   1       unsigned char i;
 182   1       unsigned char Data_read;
 183   1      
 184   1       AD7705_CS = 0;                    //选通片选
 185   1       AD7705_CLK = 1;
 186   1       _nop_();
 187   1       for(i = 0; i < 8; i++) 
 188   1       {
 189   2           AD7705_CLK = 0;
 190   2           _nop_();
 191   2           _nop_();
 192   2          Data_read <<= 1;
 193   2          Data_read |= (unsigned char)AD7705_DATA;
 194   2          _nop_();
 195   2          _nop_();
 196   2          AD7705_CLK = 1;
 197   2          _nop_();
 198   2          _nop_();
 199   2       }
 200   1         _nop_();
 201   1        AD7705_CS = 1;
 202   1        while (! AD7705_DRDY);
 203   1        return(Data_read);
 204   1      }
 205          //------------------------------------------------------------------
 206          //函数名：AD7705_Start
 207          //功能：向AD7705的各寄存器写入初始控制字
 208          //参数：无
 209          //返回值：无
 210          //变量：无
 211          //备注：无
 212          //------------------------------------------------------------------
 213          void AD7705_Start(unsigned char n)
 214          { 
 215   1        unsigned char i;
 216   1       delay_ms(50); 
 217   1       
 218   1      for(i=0;i<35;i++)
 219   1      { /* 多于连续32个 DIN=1 使串口复位 */
 220   2         AD7705_CLK=0;
 221   2         delay_us(AD_CLK_WIDTH);
 222   2         AD7705_DATA =1;
 223   2         delay_us(AD_CLK_WIDTH);
 224   2         AD7705_CLK=1;
 225   2         delay_us(AD_CLK_WIDTH);
 226   2      }
 227   1       AD7705_Write_Reg(0x20);       //设置下一步写时钟寄存器，并且选择第一对差分通道
 228   1       AD7705_Write_Reg(0x08); //输出更新频率20HZ，滤波器截止频率为5.24HZ
 229   1                               //进行二分频而且工作频率大于2M
 230   1       AD7705_Write_Reg(0x10);       //选定设置寄存器并且进行写操作
 231   1       AD7705_Write_Reg(0x7a);       //自校准、增益为128、双极性缓冲模型
 232   1       AD7705_Write_Reg(0x21);
 233   1       AD7705_Write_Reg(0x08);       
 234   1       AD7705_Write_Reg(0x11);       //选定设置寄存器并且进行写操作
 235   1       AD7705_Write_Reg(0x7a);           //自校准、增益为128、双极性缓冲模型       
 236   1      }
*** WARNING C280 IN LINE 213 OF ad7705-1602.c: 'n': unreferenced local variable
 237          
 238          //------------------------------------------------------------------
 239          //函数名：AD7705_Read
 240          //功能：从AD7705数据寄存器中读数据
C51 COMPILER V9.57.0.0   AD7705_1602                                                       06/04/2020 17:55:56 PAGE 5   

 241          //参数：无
 242          //返回值：无
 243          //变量：无
 244          //备注：无
 245          //-------------------------------------------------------------------
 246          void AD7705_Read(unsigned char n)
 247          { 
 248   1        
 249   1       AD7705_Write_Reg(0x38+n);      //选择AD7705中的数据寄存器
 250   1       while(AD7705_DRDY);    
 251   1       MSB_Data = AD7705_Read_Reg();      //读出AD7705中数据寄存器的高八位
 252   1       LSB_Data = AD7705_Read_Reg();      //读出AD7705中数据寄存器的低八位
 253   1       ndata= MSB_Data*256+ LSB_Data;
 254   1       if(ndata>32768)
 255   1        {
 256   2        ndata=ndata-32768;
 257   2        }
 258   1        else
 259   1        ndata=32768-ndata;
 260   1      
 261   1      }
 262          
 263          
 264          
 265          
 266          //--------------------------------------------------------------
 267          //程序名：appear
 268          //功能：液晶显示采集的数据
 269          //参数：无
 270          //变量：无
 271          //返回值：无
 272          //备注：无
 273          //----
 274          
 275          void appear(unsigned char n)
 276          {     
 277   1        unsigned char i;
 278   1        
 279   1        for(i=0;i<5;i++)
 280   1          {
 281   2            switch (i)
 282   2            {
 283   3              case 0:no[0]=ndata/10000+48;break;
 284   3              case 1:no[1]=ndata%10000/1000+48;break;
 285   3              case 2:no[2]=ndata%1000/100+48;break;
 286   3              case 3:no[3]=ndata%100/10+48;break;
 287   3              case 4:no[4]=ndata%10+48;break; 
 288   3            }
 289   2            LCD_write_com(0x80+i+n*0x40); 
 290   2            LCD_write_Data(no[i] );
 291   2          }
 292   1       
 293   1      
 294   1      }
 295          
 296          /******************************************************************/
 297          /*                   主函数                                       */
 298          /******************************************************************/  
 299          main()
 300          {
 301   1       
 302   1      LCD_init(); 
C51 COMPILER V9.57.0.0   AD7705_1602                                                       06/04/2020 17:55:56 PAGE 6   

 303   1       
 304   1      EA = 1;           //允许CPU中断
 305   1      ET0 = 1;          //定时器0中断打开
 306   1      TMOD = 0x51;      //设定时器0,1为模式1，16位模式
 307   1      TH1=0x00; TL1=0x00;
 308   1      TH0=0x3c; TL0=0xb0;     //设定时值为50ms
 309   1      TR0 = 1;
 310   1                //开始定时
 311   1      
 312   1       delay_ms(100);
 313   1      while(1)
 314   1      {  
 315   2          R_S=0;
 316   2          delay_us(10); 
 317   2          R_S=1;
 318   2          delay_us(100);
 319   2          AD7705_Start(0);
 320   2          AD7705_Read(0);           //读AD7705数据寄存器中数据
 321   2          appear(0);              
 322   2          delay_ms(10); 
 323   2          AD7705_Start(1); 
 324   2          AD7705_Read(1);           //读AD7705数据寄存器中数据
 325   2          appear(1);              
 326   2          delay_ms(1); 
 327   2       }
 328   1      }
 329          
 330          /*******/
 331          
 332          void TM_Time0(void) interrupt 1 //定时器0中断
 333          { 
 334   1      
 335   1         unsigned char Dm;
 336   1          TH0=0x3c;TL0=0xb0;
 337   1        TR0=1;
 338   1          Timerint1++; 
 339   1        if(Timerint1==10)
 340   1         { 
 341   2          Timerint2++; 
 342   2      
 343   2          if(Timerint2==2)
 344   2         {
 345   3          Timerint2=0;
 346   3            Sec++; 
 347   3            if (Dm==0)Dm=1;
 348   3      
 349   3          if (Sec>59)
 350   3            {
 351   4          if(Alm==1)
 352   4          {AT++;
 353   5           if(AT>AlmTime)AT=AlmTime;}
 354   4           else AT=0;
 355   4          Min++;
 356   4          Sec=0;
 357   4          if(Min>10)Dm=0;
 358   4           if(Min>59)
 359   4            {
 360   5            H++;
 361   5            Min=0;
 362   5            if(H==24)H=0;
 363   5            }
 364   4          } 
C51 COMPILER V9.57.0.0   AD7705_1602                                                       06/04/2020 17:55:56 PAGE 7   

 365   3         }
 366   2        Timerint1=0;
 367   2        }   
 368   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    750    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     18       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
